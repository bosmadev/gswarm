# Claude Code GitHub Workflow
#
# Description: AI-powered code review, PR automation, and security analysis using Claude
#
# Usage:
#   - Comment: "@claude review" on issues/PRs
#   - Label: Add "claude" label to PR
#   - Assign: Assign "claude[bot]" to issue/PR
#   - Manual: Run via Actions tab with custom prompts
#
# Required Secrets:
#   - CLAUDE_CODE_OAUTH_TOKEN: OAuth token from `claude auth login` + `/token sync`
#   - GITHUB_TOKEN: Auto-provided by GitHub Actions
#
# Documentation: See ~/.claude/CLAUDE.md § GitHub Actions Workflow Template

name: Claude Code

on:
  issue_comment:
    types: [created]
  pull_request_review_comment:
    types: [created]
  pull_request_review:
    types: [submitted]
  issues:
    types: [opened, assigned, labeled]
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review, labeled, edited, converted_to_draft]

  # Manual trigger - "Summarize PR" button in Actions tab
  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        required: false
        type: choice
        options:
          - 'Summarize changes in this PR'
          - 'Review code quality'
          - 'Security audit (OWASP)'
          - 'Custom prompt'
        default: 'Summarize changes in this PR'
      custom_prompt:
        description: 'Custom prompt (if action is Custom prompt)'
        required: false
        type: string
      model:
        description: 'Model'
        required: false
        type: choice
        options:
          - claude-sonnet-4-5-20250929
          - claude-sonnet-4-5-20250929[1m]
          - claude-opus-4-6
          - claude-haiku-4-5-20251001
        default: claude-sonnet-4-5-20250929
      effort:
        description: 'Effort level (Opus only)'
        required: false
        type: choice
        options:
          - high
          - medium
          - low
        default: high
      max_turns:
        description: 'Max conversation turns'
        required: false
        type: number
        default: 25
      timeout:
        description: 'Timeout (minutes)'
        required: false
        type: number
        default: 30

  # Auto-update CHANGELOG on merge
  push:
    branches: [main, master]

  # FUTURE: Uncomment for daily health check across codebases
  # Runs at 9 AM on weekdays, pings each repo with a quick status check
  # Cost control: Set max_turns=5 and model=haiku in scheduled job 'if' block below
  # schedule:
  #   - cron: '0 9 * * 1-5'  # 9 AM Mon-Fri
  # To enable: uncomment above and add to job 'if' condition:
  #   (github.event_name == 'schedule' && github.event.inputs.max_turns <= 5 && github.event.inputs.model == 'claude-haiku-4-5-20251001') ||

# Prevent concurrent runs
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.event.issue.number || github.ref }}
  cancel-in-progress: true

permissions:
  id-token: write
  contents: read  # Default read-only, scoped per-job below
  issues: write
  pull-requests: write
  actions: read

jobs:
  # ============================================
  # Job 1: Claude AI Code Review
  # ============================================
  # Security: Only org members can trigger via comment. Manual dispatch requires write access.
  # PR open trigger requires 'claude' label to opt-in (prevents abuse on public repos).
  claude:
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@claude review') && github.event.comment.author_association != 'NONE') ||
      (github.event_name == 'pull_request_review_comment' && contains(github.event.comment.body, '@claude review') && github.event.comment.author_association != 'NONE') ||
      (github.event_name == 'pull_request_review' && contains(github.event.review.body, '@claude review') && github.event.review.author_association != 'NONE') ||
      (github.event_name == 'issues' && github.event.action == 'assigned' && github.event.assignee.login == 'claude[bot]') ||
      (github.event_name == 'issues' && github.event.action == 'opened' && contains(github.event.issue.body, '@claude review') && github.event.issue.author_association != 'NONE') ||
      (github.event_name == 'pull_request' && github.event.action == 'labeled' && github.event.label.name == 'claude') ||
      (github.event_name == 'pull_request' && github.event.action == 'opened' && contains(github.event.pull_request.labels.*.name, 'claude'))
    runs-on: ubuntu-latest
    timeout-minutes: ${{ github.event.inputs.timeout && github.event.inputs.timeout <= 60 && github.event.inputs.timeout || 30 }}
    permissions:
      contents: read  # Read code only, no write access

    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 50  # Limit to 50 commits for performance, sufficient for most reviews

      - name: Setup Node.js with caching
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Validate Required Packages
        run: |
          # Verify packages exist in npm registry before installation
          npm view @modelcontextprotocol/server-sequential-thinking version || exit 1
          npm view @context7/mcp-server version || exit 1

      - name: Create MCP Configuration
        run: |
          cat > /tmp/mcp-config.json << 'EOF'
          {
            "mcpServers": {
              "sequential-thinking": {
                "command": "npx",
                "args": ["-y", "@modelcontextprotocol/server-sequential-thinking"]
              },
              "context7": {
                "command": "npx",
                "args": ["-y", "@context7/mcp-server"]
              }
            }
          }
          EOF
          # NOTE: Only sequential-thinking and context7 included for CI safety
          # Serena/Playwriter excluded - risk of infinite loops burning minutes

      - name: Validate Claude Token Secret
        run: |
          if [ -z "${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}" ]; then
            echo "::error::CLAUDE_CODE_OAUTH_TOKEN secret is not set. Run 'claude auth login' then '/token sync'"
            exit 1
          fi

      - name: Claude Code Action
        uses: anthropics/claude-code-action@v1
        env:
          CLAUDE_CODE_EFFORT_LEVEL: ${{ inputs.effort || 'high' }}
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          trigger_phrase: "@claude review"
          assignee_trigger: "claude[bot]"
          label_trigger: "claude"
          base_branch: "main"
          branch_prefix: ""
          branch_name_template: "{{entityType}}-{{entityNumber}}-{{description}}"
          allowed_bots: "dependabot[bot],renovate[bot]"
          track_progress: true
          use_sticky_comment: true
          include_fix_links: true
          use_commit_signing: true
          # Security: Removed cp/mv - use Write/Edit tools instead for file manipulation
          # max_turns capped at 50 to prevent runaway costs
          claude_args: |
            --max-turns ${{ github.event.inputs.max_turns <= 50 && github.event.inputs.max_turns || '25' }}
            --model ${{ github.event.inputs.model || 'claude-sonnet-4-5-20250929' }}
            --mcp-config /tmp/mcp-config.json
            --allowedTools "mcp__sequential-thinking__sequentialthinking,mcp__context7__*,Bash(gh:*),Bash(npm:*),Bash(pnpm:*),Bash(git status:*),Bash(git diff:*),Bash(git log:*),Bash(git show:*),Bash(ls:*),Bash(cat:*),Bash(head:*),Bash(tail:*),Bash(tree:*),Bash(find:*),Bash(wc:*),Bash(grep:*),Bash(echo:*),Bash(pwd:*),Read,Write,Edit,MultiEdit,Glob,Grep,Task"
          prompt: |
            ## Context
            - Repository: ${{ github.repository }}
            - Event: ${{ github.event_name }}
            - Actor: ${{ github.actor }}

            ## Review Criteria
            Follow these review criteria:
            - OWASP Top 10 security checklist (injection, auth, data exposure, XXE, broken access control, security misconfig, XSS, insecure deserialization, vulnerable dependencies, insufficient logging)
            - Code quality patterns and anti-patterns (DRY, SOLID, proper error handling, no god objects)
            - Framework-specific best practices (React hooks, Next.js routing, TypeScript strict mode)
            - Accessibility (WCAG AAA) standards (keyboard nav, ARIA labels, semantic HTML, color contrast)
            - Performance and scalability considerations (bundle size, lazy loading, database queries, caching)

            ## Action
            ${{ github.event.inputs.action == 'Summarize changes in this PR' && '
            Summarize this PR in clear English paragraphs:
            1. **What changed** - List files added, modified, deleted
            2. **Why it changed** - Infer purpose from commit messages and code
            3. **Impact** - What this affects (APIs, UI, tests, etc.)
            4. **Review notes** - Any concerns or suggestions

            Format as a clean comment/description for the PR.
            ' || '' }}
            ${{ github.event.inputs.action == 'Review code quality' && 'Review code quality: style, patterns, potential bugs, test coverage. Apply criteria from pr-review-base.md.' || '' }}
            ${{ github.event.inputs.action == 'Security audit (OWASP)' && 'Perform OWASP Top 10 security audit. Check for injection, auth issues, data exposure. Use pr-review-base.md OWASP checklist.' || '' }}
            ${{ github.event.inputs.action == 'Custom prompt' && github.event.inputs.custom_prompt || '' }}

            ## Bot PR Guidelines (Dependabot/Renovate)
            Bot PR detected: ${{ contains(fromJSON('["dependabot[bot]", "renovate[bot]"]'), github.actor) && 'YES' || 'NO' }}
            If this is a bot-generated PR (github.actor in allowed_bots list):
            - Review the changes but DO NOT auto-merge
            - Leave assessment as a comment
            - List steps for manual resolution if needed
            - User will pull to CLI to resolve manually

  # ============================================
  # Job 2: Auto-update CHANGELOG + Version Bump
  # ============================================
  changelog:
    name: Update CHANGELOG & Version
    if: |
      github.event_name == 'push' &&
      github.actor != 'github-actions[bot]' &&
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Required to commit and push CHANGELOG + version updates

    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 2

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '25'

      - name: Update CHANGELOG and bump version (consolidated)
        run: node --experimental-transform-types .github/changelog.ts

  create-release:
    name: Create Release
    needs: changelog
    if: |
      github.event_name == 'push' &&
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Required to create tags and releases
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0  # Full history for tag creation

      - name: Pull latest changes
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git pull --rebase origin ${{ github.ref_name }} || true

      - name: Create tag and release
        uses: actions/github-script@v7
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          script: |
            const fs = require('fs');
            const { execSync, spawnSync } = require('child_process');

            function safeExec(cmd, errorMsg) {
              // Validate command is safe (git/find only, no shell expansion)
              const allowedCommands = /^(git|find)\s/;
              if (!allowedCommands.test(cmd)) {
                throw new Error(`Unsafe command rejected: ${cmd}`);
              }
              try {
                return execSync(cmd, { encoding: 'utf8', stdio: ['pipe', 'pipe', 'pipe'] });
              } catch (error) {
                console.error(`${errorMsg}: ${error.message}`);
                throw new Error(`${errorMsg}: ${error.stderr || error.message}`);
              }
            }

            // Find package.json (exclude node_modules)
            let pkgPath = null;
            try {
              const result = safeExec('find . -name "package.json" -not -path "*/node_modules/*" | head -1', 'Failed to find package.json').trim();
              if (result) pkgPath = result;
            } catch (e) {
              console.log('No package.json found, skipping release');
              return;
            }

            if (!pkgPath || !fs.existsSync(pkgPath)) {
              console.log('No package.json found, skipping release');
              return;
            }

            // Read version from package.json
            const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
            const version = pkg.version || '0.0.0';
            const tagName = `v${version}`;

            console.log(`Creating release for version ${version}`);

            // Check if tag already exists
            try {
              const existingTags = safeExec('git tag -l', 'Failed to list tags');
              if (existingTags.split('\n').includes(tagName)) {
                console.log(`Tag ${tagName} already exists, skipping release`);
                return;
              }
            } catch (error) {
              console.log('No existing tags found');
            }

            // Extract build ID from commit message
            const commitMsg = safeExec('git log -1 --pretty=format:%B', 'Failed to get commit message').trim();
            const commitSubject = commitMsg.split('\n')[0];
            const buildMatch = commitSubject.match(/Build\s+(\d{1,6})/i);
            const buildId = buildMatch ? buildMatch[1] : null;

            console.log(`Build ID: ${buildId || 'not found'}`);

            // Extract release notes from CHANGELOG
            let releaseNotes = '';
            const changelogPath = 'CHANGELOG.md';

            if (fs.existsSync(changelogPath) && buildId) {
              const changelog = fs.readFileSync(changelogPath, 'utf8');
              // Match new badge format: "| Build {id}" or old "## Build {id}"
              const buildRegex = new RegExp(`Build ${buildId}(\\s|\\||$)`, 'm');
              const match = changelog.match(buildRegex);

              if (match) {
                const matchIdx = changelog.indexOf(match[0]);
                // Find the --- separator before this entry
                const prevSep = changelog.lastIndexOf('\n---', matchIdx);
                const startIdx = prevSep !== -1 ? prevSep + 1 : matchIdx;
                // Find the next --- separator after this entry
                const nextSep = changelog.indexOf('\n---', matchIdx + 1);
                const endIdx = nextSep !== -1 ? nextSep : changelog.length;
                const section = changelog.slice(startIdx, endIdx).trim();

                // Remove the --- and badge line, keep content
                const lines = section.split('\n');
                const contentLines = lines.filter(l => !l.startsWith('---') && !l.startsWith('[!['));
                releaseNotes = contentLines.join('\n').trim();

                console.log('Extracted release notes from CHANGELOG');
              } else {
                console.log(`No CHANGELOG entry found for Build ${buildId}`);
              }
            }

            // Fallback to generic release notes if none found
            if (!releaseNotes) {
              releaseNotes = buildId
                ? `Release for Build ${buildId}\n\nSee commit history for details.`
                : `Release version ${version}\n\nSee commit history for details.`;
              console.log('Using generic release notes');
            }

            // Create annotated git tag using spawnSync (not in safeExec allowlist)
            const tagMessage = buildId ? `Build ${buildId} | ${version}` : `Release ${version}`;
            console.log(`Creating tag ${tagName} with message: ${tagMessage}`);

            const tagResult = spawnSync('git', ['tag', '-a', tagName, '-m', tagMessage], { encoding: 'utf8' });
            if (tagResult.error || tagResult.status !== 0) {
              throw new Error(`Failed to create tag: ${tagResult.stderr || tagResult.error?.message}`);
            }

            // Push tags
            console.log('Pushing tags to remote');
            const pushResult = spawnSync('git', ['push', 'origin', '--tags'], { encoding: 'utf8' });
            if (pushResult.error || pushResult.status !== 0) {
              throw new Error(`Failed to push tags: ${pushResult.stderr || pushResult.error?.message}`);
            }

            // Write release notes to temp file to avoid shell escaping issues
            const notesPath = '/tmp/release-notes.md';
            fs.writeFileSync(notesPath, releaseNotes);

            // Create GitHub Release using gh CLI
            const releaseTitle = buildId ? `Build ${buildId} | ${version}` : version;
            console.log(`Creating GitHub Release: ${releaseTitle}`);

            const ghResult = spawnSync('gh', [
              'release', 'create', tagName,
              '--title', releaseTitle,
              '--notes-file', notesPath
            ], { encoding: 'utf8' });

            if (ghResult.error || ghResult.status !== 0) {
              throw new Error(`Failed to create GitHub Release: ${ghResult.stderr || ghResult.error?.message}`);
            }

            console.log(`✅ Successfully created release ${tagName}`);

            // Clean up temp file
            fs.unlinkSync(notesPath);
